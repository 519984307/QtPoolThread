# Pool Thread Qt

*Table of Contents*
---------

- [ About ](#About_Project)
- [ Requirements ](#dependencies)
- [ Usage ](#Usage)
- [ Contacts ](#Contacts)


<a name="About_Project"></a>
## About

-----------
Пул потоков представляет собой инструмент для параллельного выполнения в программе. 
Параллельное выполнение задач увеличивает производительность и позволяет избежать задержек при выполнении из-за частого создания и уничтожения потоков для краткосрочных задач.
Количество доступных потоков настраивается исходя из вычислительных способностей устройства, но также имеется поддержка ручного ввода кол-ва потоков (не превышающие числа доступных).
Фреймворк Qt предлагает множество инструментов для многопоточности высокого(Qt Concurrent(построен поверх QThreadPool) + QFuture) и низкого уровня( QRunnable + QThreadPool, QMutex + QThread). 
1) Qt Concurrent делает программирование проще, убирая необходимость низкоуровневой синхронизации (мьютексы), и управляет несколькими потоками автоматически, исходя из числа доступных устройству.
Такие инструменты, как QFuture, QFutureWatcher и QFutureSynchronizer используются для доступа и получения результатов вычислений. 
2) Также можно использовать более низкоуровневую альтернативу для управления потоками. QThreadPool представляет такую возможность.  QThreadPool - это набор повторно используемых QThread.
3) Главное отличие QThread в том, что QThread может запускать цикл событий. Каждый экземпляр QThread представляет и управляет одним потоком. В этом случае поток может получать обновления данных через сигналы
Первые 2 инструменты Qt хорошо подходят для ситуаций , когда нужно выполнить некоторую фоновую обработку в одной или нескольких вторичных потоков без необходимости полной мощности и гибкости , предоставляемой QThread

В этом репозитории содержится самый простой пример создания пула потоков QThread. 
Идея уже давно не новая, строится на том, что создается очередь и "рабочие" (Workers), который существуют в собственных потоках и обрабатывает очередь. 
Worker забирает задачи одну за другой, в то время, как программа (Потребитель ) в этом время может добавлять задачи в эту очередь.
Механизм сигнала / слота используется для добавления задачи, а цикл событий (LoopFunc), запущенный внутри потока, будет служить очередью, позволяющей выполнять только один слот за раз.

<a name="dependencies"></a>
## Requirements/dependencies

-----------
Используются следующие зависимости:
- cmake (использовался 3.12)
- QtCore


<a name="Usage"></a>
## Usage

-----------
В конструкторе потребителя:
```
    worker = new PoolThread();
    worker->moveToThread(threadWorker);
    connect(this, &Consumer::addTask_, worker, &PoolThread::addTask_, Qt::DirectConnection);
    connect(this, &Consumer::startWork, worker,&PoolThread::init_,Qt::DirectConnection);
    connect(threadWorker, &QThread::finished, worker, &QObject::deleteLater);
    threadWorker->start();
```

Передаем сигнала старта работы
```
    int numThreads = 4;
    emit startWork(numThreads);
```

Передаем с помощью addTask функции и аргументы, которые необходимо выполнить
```
    for (int i = 0; i < numTasks; i++){
        const std::function<QVariant(QVariant)> f_ = &TestConsumer::testFactorial;
        emit addTask_(f_, QVariant(i + 42));
    }

```
Уничтожаем созданные потоки при завершении
```
    worker->deinit_();
```

<a name="Contacts"></a>
## Contacts

-----------

- Telegram : <a href="https://telegram.org" target="_blank">`@fom_alyona`</a>
- Email : fomalyona11@gmail.com.


